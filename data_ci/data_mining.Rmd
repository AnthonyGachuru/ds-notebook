---
title: "ML Flashcards"
author: "Gordon"
date: "April 23, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## CSV to SQL DB

$ sqlite3 db_name.db
sqlite> .mode csv db_name
sqlite> .import data.csv db_name

conda create -n yourenvname python=x.x anaconda

[Temp Pandas Columns](https://github.com/jreback/PyDataNYC2015/blob/master/whats-new-in-pandas/v0.16.x.ipynb)

[CSV to Database](https://gist.github.com/gfleetwood/c2ea91da4a8ab1a77f777e28e0b2949c)

Sampling a massive CSV file:

pip install subsample

gzcat ginormous.csv.gz | subsample -n 100000 > sampled.csv.gz

logging converts multiplicative relationships to additive relationships, and by the same token it converts exponential (compound growth) trends to linear trends. By taking logarithms of variables which are multiplicatively related and/or growing exponentially over time, we can often explain their behavior with linear models.

## Scraping

* Access robots.txt: website_url.domain/robots.txt

* botnet beautiful soup scraping

* user agent switching

* Try polling in your wait about every 500 milliseconds. Also use presence of element located. I generally have better luck with that expected condition than visibility. Also, submit the search using the search button.

Selenium: save_screenshot selenium, forward(), back(), maximize(), use action_chains to do stuff like scroll find_element_by_link_name, element_to_be_clickable, visibility_of_element_located

```{python}
from pyvirtualdisplay import Display  
from selenium import webdriver  
display = Display(visible=0, size=(800, 600))  
display.start()  
browser = webdriver.Firefox()  
browser.get('http://www.google.com')  
print browser.title  
browser.quit()  
display.stop()
```

##SQL Lite

* List tables: SELECT name FROM sqlite_master WHERE type='table';

* Show columns: .headers ON

## Other

* [json normalize](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.io.json.json_normalize.html)


SQL joins allow you to combine two datasets side-by-side, but UNION allows you to stack one dataset on top of the other. Note that UNION only appends distinct values. More specifically, when you use UNION, the dataset is appended, and any rows in the appended table that are exactly identical to rows in the first table are dropped. If you’d like to append all the values from the second table, use UNION ALL

CAST(column_name AS integer)
Note that you should not include an alias when you write a subquery in a conditional statement. 
ROW_NUMBER(), RANK() and DENSE_RANK()
NOW() + INTERVAL 
artist IS NULL
artist IS NOT NULL
song_name NOT ILIKE '%a%': case insensitive
ORDER BY year DESC, year_rank
COUNT(DISTINCT month)
count(col_name_or_col_index) returns count of non-null values like table in R
The CASE statement is followed by at least one pair of WHEN and THEN statements:
CASE WHEN year = 'SR' THEN 'yes' ELSE NULL END
You can also define a number of outcomes in a CASE statement by including as many WHEN/THEN statements as you’d like

If you include two (or more) columns in a SELECT DISTINCT clause, your results will contain all of the unique pairs of those two columns

Can use AND right after JOIN to filter before joining. Using WHERE filters after joining.
