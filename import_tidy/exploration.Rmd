---
title: "Placeholder"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## General

* import pandas_profiling; pandas_profiling.ProfileReport(data)

* [Optimal Bins For Histogram](https://stats.stackexchange.com/questions/798/calculating-optimal-number-of-bins-in-a-histogram/862#862)

* **The Coefficient of Unalikeability**: (Unalikeability is defined as how often observations differ from one another). It varies from 0 to 1. The higher the value, the more unalike the data are.

## Missingness & Imputation

There are three types of missingness: 1) Completely at Random, 2) At Random, 3) Not at random

The pros of imputation:

* Helps retain a larger sample size of your data.

* Does not sacrifice all the available information in an observation because of sparse missingness.

* Can potentially avoid unwanted bias.

The cons of imputation:

* The standard errors of any estimates made during analyses following imputation can tend to be too small.

* The methods are under the assumption that all measurements are actually “known,” when in fact some were imputed.

* Can potentially induce unwanted bias.

Other notes:

* dplyr::case_when

* na.omit(): Similar to complete cases.

* mean of each column = df.mean(axis = 0) || df.mean(axis = 'index' )

* mean of each row = df .mean(axis = 1) || df .mean(axis = 'columns' ) 

## Data Table

* Operations done by reference

* dt[i, j, by] : subset by i calculate by j grouped using by

* 1: numeric | 1L: integer

* NA_integer_: integer

* DT[.N] : prints last row

* names(DT): colnames

* dim(DT): dimensions

* DT[, .(A, B)]: returns two columns

* DT[, c(A, B)]: returns a concatenated vector

* DT[, .(sum_c = sum(C)]

* DT[, plot(A, C)]

* DT[, A:=NULL]: Remove column A

* DT[, .(sumB = sum(B)), by = .(Grp = A%%2)]

* DT[, .N, by = Sepal.Width]: .N is the count of each group

* DT[, lapply(.SD, median)]: .SD is a placeholder for all the columns

* dogs[, lapply(.SD, mean), .SDcols = 2:3]: Find mean of columns 2 & 3

* for (i in 1:5) set(DT, i, 3L, i+1): update first 5 rows of 3rd column

* setnames(DT, 'y', 'z'): changes colname from y to z

* setkey(DT, A, B)

* DT[.('b')]

* DT[.(c('b', 'c'))]

* DT[.(c('b', 'c')), mult="first"]

* DT[c("b", "c"), .SD[c(1, .N)], by = .EACHI]: First and last row of the "b" and "c" groups

* DT[c("b", "c"), { print(.SD); .SD[c(1, .N)] }, by = .EACHI]

* roll=TRUE, 'nearest', -Inf, Inf | rollends=FALSE












